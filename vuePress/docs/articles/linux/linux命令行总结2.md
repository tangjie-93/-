## 第二章  配置环境和shell环境

​		`shell`在环境中存储了两种基本类型的数据——**环境变量和`shell`变量**。`shell`变量是`bash`存放的少量数据，剩下的基本都是环境变量。

```js
• printenv - 打印部分或所有的环境变量
• set - 设置 shell 选项
• export — 导出环境变量，让随后执行的程序知道。
• alias - 创建命令别名
```

### 1、shell环境

**1、环境变量**

​		如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。 输入不带参数的 alias 命令来查看它们:

```js
printenv USER //打印特定变量的数值
echo $USER //打印特定用户的数值
set | less //输出结果按照字母顺序排列：
alas //显示所有的别名
foo='this is a test'//添加环境变量
```

**2、如何建立shell环境**

​		当我们登录系统后，启动 bash 程序，并且会读取一系列称为**启动文件**的配置脚本， 这些文件定义了默认的可供所有用户共享的 shell 环境。精确的启动顺序依赖于要运行的 shell 会话 类型。有两种 shell 会话类型：一个是**登录 shell 会话**，另一个是**非登录 shell 会话**。

非登录`shell`用户会读取一下文件。

| 文件             | 内容                                                         |
| ---------------- | ------------------------------------------------------------ |
| /etc/bash.bashrc | 应用于所有用户的全局配置文件。                               |
| ~/.bashrc        | 用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |

登录shell会话的启动文件。

| 文件            | 内容                                                         |
| --------------- | ------------------------------------------------------------ |
| /etc/profile    | 应用于所有用户的全局配置脚本。                               |
| ~/.bash_profile | 用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |
| ~/.bash_login   | 如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。 |
| ~/.profile      | 如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取 这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。 |

​		PATH 变量经常（但不总是，依赖于发行版）在 /etc/profile 启动文件中设置，修改PATH变量，添加目录到PATH目录列表的末尾。

**3、激活我们的修改**

​		我们对于文件` .bashrc `的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 `.bashrc `文件只是在**刚开始启动终端会话时读取**。但是通过 `source .bashrc`可以强迫`bash`重新读取修改过的文件。

```js
vi .bashrc //使用文编编辑器编辑文件
source .bashrc //bash重新读取编辑过的文件
```



### 2、vi编辑器

​		使用`vi`编辑器的理由。

+ vi编辑器很多系统都预装了。

+ vi是轻量级且执行速度很快的编辑器。

  vim（vi improved）是“vi”的一款高级替代版本。vim通常是linux系统“vi”的符号链接(别名)。

**1、停止和启动vi**

```js
vi file//启动vi
:q //退出vi
:q! //修改了文件，强制不保存退出
:wq //修改了文件，保存退出

```

**2、移动光标**

| 按键                | 移动光标                                          |
| ------------------- | ------------------------------------------------- |
| l or 右箭头         | 向右移动一个字符                                  |
| h or 左箭头         | 向左移动一个字符                                  |
| j or 下箭头         | 向下移动一行                                      |
| k or 上箭头         | 向上移动一行                                      |
| 0 (零按键)          | 移动到当前行的行首。                              |
| ^                   | 移动到当前行的第一个非空字符。                    |
| $                   | 移动到当前行的末尾。                              |
| w                   | 移动到下一个单词或标点符号的开头。                |
| W                   | 移动到下一个单词的开头，忽略标点符号。            |
| b                   | 移动到上一个单词或标点符号的开头。                |
| B                   | 移动到上一个单词的开头，忽略标点符号。            |
| Ctrl-f or Page Down | 向下翻一页                                        |
| Ctrl-b or Page Up   | 向上翻一页                                        |
| numberG             | 移动到第 number 行。例如，1G 移动到文件的第一行。 |
| G                   | 移动到文件末尾。                                  |

**3、基本编辑**

+ 基本编辑：进入`vi`编辑器时，默认是**编辑模式**，在键盘上按下`insert`或者`i`后进入插入模式，此时可以输入文本。按下`Esc`退出插入模式返回到**命令模式**。按下`u` 按键，当在命令模式下，vi 将会撤销你所做的最后一次修改。

+ 追加文本：vi 提供了**追加文本**的命令，明智地命名为"a"命令。 vi 提供了一种快捷方式（"A"命令）来移动到当前行的末尾，并且能添加文本。

+ 打开一行。这会在存在的两行之间插入一个空白行，并且进入插入模式。 把光标移动到某一行上，按下`o`，在当前行的下方打开一行，按下`O`，在当前行的上方打开一行。

+ 删除文本：

  | 命令 | 删除的文本                             |
  | ---- | -------------------------------------- |
  | x    | 当前字符                               |
  | 3x   | 当前字符集其后的两个字符               |
  | dd   | 当前行                                 |
  | 5dd  | 当前行及随后的四行文本                 |
  | dW   | 从光标位置开始到下一个单词的开头       |
  | d$   | 从光标位置开始到当前行的行尾           |
  | d0   | 从光标位置开始到当前行的行首           |
  | d^   | 从光标位置开始到文本行的第一个非空字符 |
  | dG   | 从当前行到文件的末尾                   |
  | d20G | 从当前行到文件的第20行。               |

+ 剪切、复制和粘贴文本：使用 d 命令，删除的部分被复制到一个 粘贴缓冲区中（看作剪切板）。过后我们执行**小 p命令把剪切板中的文本粘贴到光标位置之后， 或者是大 P 命令把文本粘贴到光标之前。y 命令来“拉”（复制）文本，和 d 命令剪切文本的方式差不多。**

+ 链接行：大写的 J把行与行之间连接起来。

+ 查找和替换：**f命令查找一行**。例如，命令 fa 会把光标定位到同一行中 下一个出现的"a"字
  符上。在一行中执行了字符的查找命令之后，通过输入分号来重复这个查找。`/`用于查找整个文件。当你输
  入/命令后，一个"/"字符会出现在屏幕底部。下一步，输入要查找的单词或短语后， 按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 `n `命令来重复先前的查找。

+ 全局查找和替换：vi 使用 ex 命令来执行查找和替代操作。

  ```js
  :%s/Line/line/g //全局将Line替换为line
  ```

  | 条目       | 含义                                                         |
  | ---------- | ------------------------------------------------------------ |
  | ：         | 运行一个`ex`命令                                             |
  | %          | 指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范 围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意 思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对 当前行生效。 |
  | s          | 指定操作。在这种情况下是，替换（查找与替代）。               |
  | /Line/line | 查找类型与替代文本。                                         |
  | g          | 这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操 作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。 |

  ```
  :%s/Line/line/gc //全局将Line替换为line,并会出来提示框。
  ```

  | 按键           | 行为                                                 |
  | -------------- | ---------------------------------------------------- |
  | y              | 执行替换操作                                         |
  | n              | 跳过这个匹配的实例                                   |
  | a              | 对这个及随后所有匹配的字符串执行替换操作。           |
  | q or esc       | 退出替换操作。                                       |
  | l              | 执行这次替换并退出。l 是 “last” 的简写。             |
  | Ctrl-e, Ctrl-y | 分别是向下滚动和向上滚动。用于查看建议替换的上下文。 |

+ 编辑多个文件 `vi file1 file2...`

+ 文件之间转换。`:n`从这个文件转到下一个文件。在切换这些命令的时候可能需要执行`:w 1.txt`来先保存编辑的文件，然后再切换。 `:N`回到先前的文件。我们可以查看正在编辑的文件列表，使用`:buffers` 命令。运行这个 命令后，屏幕顶部就会显示出一个文件列表。这时要使用:buffer 命令， 其后加上缓冲区号码，来转换文件。

+ 从一个文件复制内容到另一个文件。

  ```
  :buffer 1//转到缓冲区编号为1的文件 通过`yy`等命令来复制内容。
  :buffer 2//转到编号为的文件，将粘贴区的文件进行复制。
  ```

+ 插入整个文件到另一个文件。

  ```js
  :r foo.txt //把指定的文件插入到光标位置之前
  ```

+ 保存工作

  ```js
  :wq //保存退出
  :w 1.txt//保存特定的文件，如果1.txt不存在，会将正在编辑的文件另存为1.txt
  ```



### 3、自定制shell提示符

**1、解剖一个提示符**

默认提示符：包含了用户名、主机名和当前工作目录。提示符是由`PS1(prompt string one)`的环境变量定义的。

```js
[root@iZwtrtjgg3qrk8Z ~]#
echo PS1 //[\u@\h \W]\$
```

提示符中用到的转义字符。

```bash
\a		以ASCII格式编码的铃声，当遇到这个转义序列时，计算机会发出嗡嗡的响声。
\d      以日、月、天格式俩表示当前日期
\h		本地机器的主机名，不带末尾的域名
\H		完整的主机名
\j		运行在当前shell会话中的工作数
\l		当前终端设备名
\n		换行符
\r		回车符
\s		shell程序名
\t		以24小时制，'hours:minutes:seconds'的格式表示当前时间
\T		以12小时制表示当前时间
\@		以12小时工作制，AP/PM表示当前时间
\A		以24小时工作制，hours:minutes格式表示当前时间
\u		当前用户名
\v		shell程序的版本号
\V		Version and release numbers of the shell
\w		当前工作目录名
\W		当前功能工作目录的最后部分。
\!		当前命令的历史号
\#		当前会话中的命令数
\$		表示$字符，超级管理员显示#字符
\[		标志着一系列或多个非打印字符的开始
\]		标志着非打印字符的技术。
```

**2、自定义提示符**

​		可以用一个变量将当前提示符存起来，也可以在某个文件定义该提示符，然后导出，使之提示符永久存在。

```js
1、用一个变量将当前提示符保存起来；
ps1_old=$PS1;
2、自定义提示符
PS1="\a\h"。
```

----

##  第三章  常见任务和基本工具

### 1、软件包管理

​		指的是系统中一种安装和维护软件的方法。两大包管理技术阵营——Debian的".deb"和红帽的“.rpm”。

​		**包文件：**在包管理系统中软件的基本单元是**包文件**。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。

​		**资源库：** 在软件开发不同周期内存放不同性质（测试、开发）的软件包的库。

**1、上层和底层软件包工具**

​		软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。"package_name" 这个术语是指软件包实际名称，而不是指"package_file"，它是包含在软件包中的文件名。

| 发行版                                 | 底层工具 | 上层工具         |
| -------------------------------------- | -------- | ---------------- |
| Debian-Style                           | dpkg     | apt-get,aptitude |
| Fedora,Red Hat Enterprise Linux,Centos | rpm      | yum              |

**2、查找资源库中的软件包**

| 风格    | 命令                                           |
| ------- | ---------------------------------------------- |
| Debian  | apt-get update；apt-cache search search_string |
| Red Hat | yum search search_string                       |

**2、从资源库中安装一个软件包、卸载软件、更新软件**

| 功能                   | Debian                                      | Red Hat                  |
| ---------------------- | ------------------------------------------- | ------------------------ |
| 安装                   | apt-get update;apt-get install package_name | yum install package_name |
| 卸载                   | apt-get remove package_name                 | yum erase package_name   |
| 更新                   | apt-get update；apt-get upgrade             | yum update               |
| 显示所安转软件包的信息 | apt-cache show package_name                 | yum info package_name    |

**3、通过软件包文件来安装软件、经过软件包文件来升级软件**

​		从某处而不是先从资源库中下载软件包文件，可以直接使用底层工具来直接安装它们。底层软件包安装命令如下所示。

| 功能                       | Debian                      | Red Hat             |
| -------------------------- | --------------------------- | ------------------- |
| 安装软件                   | dpkg --install package_file | rpm -i package_file |
| 更新软件                   | dpkg --install package_file | rpm -U package_file |
| 确认是否安装了软件包       | dpkg --status package_name  | rpm -q package_name |
| 确定安装了那个文件的软件包 | dpkg --search file_name     | rpm -qf file_name   |
| 查看安装了那些软件包       | dpkg --list                 | rpm -qa             |

### 2、网络系统

```js
• ping - 发送 ICMP ECHO_REQUEST 软件包到网络主机
• netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员
• wget - 非交互式网络下载器
• ssh - OpenSSH SSH 客户端（远程登录程序）
```

**1、ping**

​		命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。

```js
ping 域名|IP地址
```

**2、netstat**

​		该程序被用来检查各种各样的网络设置和统计数据。

```js
netstat -ie//查看系统中的网络接口：
netstat -r //会显示内核的网络路由表
```

**3、wget**

​		wget可以从网络和FTP网站上都能下载数据。不止能下载单个文件，多个文件，甚至整个网站都能下载。wget的许多选项允许wget递归的下载，在后台下载文件（退出后仍在下载）。

**4、ssh**

​		ssh（Secure Shell）解决了与远端主机安全交流的问题。首先，它要验证远端主机是否为它所知道的那台主机（阻止了“中间人”的攻击）。其次，它加密了本地和远程主机之间所有的通讯信息。

​		ssh又两部分组成。ssh服务器在远程主机上运行，在端口22上监听将要到来的链接。ssh客户端用在本地系统中，用来与远程服务器通信。

​		当你通过 SSH 协议与远端主机建立连接的时候，其中发生的事就是在**本地与远端系统之间 创建了一条加密通道**。通常，这条通道被用来把在本地系统中输入的命令安全地传输到远端系统， 同样地，再把执行结果安全地发送回来。

​		大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 **OpenSSH**。

```js
ssh 用户名@ip地址 //使用ssh登录服务器
```

**5、scp**

```js
1、从远程系统复制文档到本地系统
scp 用户名@ip:document.txt //
2、将文件从本地复制到linux服务器
scp 文件 用户名@ip:文件名或者(.,表示就用本地文件名称)
3、将文件夹从本地复制到linux服务器
scp -r 文件夹 用户名@ip:文件名或者(.,表示就用本地文件名称)
```



### 3、查找文件

```js
• locate – 通过名字来查找文件
• find – 在目录层次结构中搜索文件
我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：
• xargs – 从标准输入生成和执行命令行
另外，我们将介绍两个命令来协助我们探索：
• touch – 更改文件时间
• stat – 显示文件或文件系统状态，展示系统对某个文件及其属性所知道的所有信息
```

**1、locate-查找文件**

​		 locate 程序支持基本的（--regexp 选项）和扩展的（--regex 选项）正则表达式

```js
locate 文件名称// locate只能依据文件名来查找文件
locate --regex 'bin/(gz|zip)' //模糊匹配bin/zip和bin/gz文件
```

**2、find-查找文件的复杂方式**

​		find 程序能基于各种各样的属性， 搜索一个给定目录（以及它的子目录），来查找文件。

```js
find ~//输出家目录列表
find ~ -type d//只搜索目录
find ~ -type f//只搜索普通文件
find ~ -type f -name "\*.jpg" -size +1M //查找所有文件名匹配 通配符模式“*.JPG”和文件大小大于（-表示小于，没有符号意味着精确匹配）1M 的文件
```

​		`type`的参数有b(块设备文件)、c(字符设备文件)、d(目录)、f(普通文件)、l(符号链接)五种类型。

​		`size`的参数有b(512个字节快，默认值)、c(字节)、w(两个字节的字)、k(1024个单位字节)、M(兆字节)、G(千兆字节)

​		find 命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要数值参数的 情况下，可以应用以上讨论的“+”和"-"符号表示法：

```bash
-cmin n 		匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。 指定少于 n 分钟 之前，使用 -					n，指定多于 n 分钟之前，使用 +n。
-cnewer file 	匹配的文件和目录的内容或属性最后修改时间早于那些文件。 
-ctime n 		匹配的文件和目录的内容和属性最后修改时间在 n\*24小时之前。 
-empty 			匹配空文件和目录。 
-group name 	匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。 
-iname pattern 	就像-name 测试条件，但是不区分大小写。 
-inum n 		匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。 
-mmin n 		匹配的文件或目录的内容被修改于 n 分钟之前。 
-mtime n 		匹配的文件或目录的内容被修改于 n\*24小时之前
-name pattern 	用指定的通配符模式匹配的文件和目录。 
-newer file 	匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。 每					次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来 决定自从上次更新，哪					一个文件已经更改了。 
-nouser 		匹配的文件和目录不属于一个有效用户。这可以用来查找属于删除帐户的文件或监测攻击行为。 
-nogroup 		匹配的文件和目录不属于一个有效的组。 
-perm mode 		匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表 示法。 
-samefile name 	相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。 
-size n 		匹配的文件大小为 n。 
-type c 		匹配的文件类型是 c。 c可以是`file(文件)、d(目录)`
-user name 		匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。
```

find文件类型

```bash
b		块设备文件
c		字符设备文件
d		目录
f		普通文件
l		符号链接
```

+ **逻辑操作符**

```bash
-and		如果操作符两边的测试条件都是真，则匹配。可以简写为`-a`
-or			操作符两边的任一个测试条件为真，则匹配。可以简写为`-o`
-not		操作符后面的测试条件为真，则匹配。简写为`!`
()			将测试条件和操作符组合起来行程更大的表达式。
```

```js
//对于文件，我们定义正确权限为0600， 目录则为0711。测试具有“不正确”权限的文件表达式为： 
find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)//表示( file with bad perms ) -or ( directory with bad perms )。
```

```js
expr1 -operator expr2
```

在所有情况下，总会执行表达式 expr1；然而由操作符来决定是否执行表达式 expr2。

+ **预定义的操作**

```bash
-delete		删除当前匹配的文件
-ls			对匹配单位文件执行等同的`ls -dils`命令。并将结果发送到标准输出
-print		把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 
-quit 		一旦找到一个匹配，退出。
```

```js
//用户家目录（和它的子目录）下搜索每个以.BAK 结尾的文件名。当找到后，就删除它们。
find ~ -type f -name '*.BAK' -delete
```

**4、用户自定义行为**

```js
-exec command {} ;// command 就是指一个命令的名字，{}是当前路径名的符号表示，分号是要求的界定符表明命令结束。
find ~ -type f -name 'foo*' -ok ls -l '{}' ';' //删除搜索到的文件，但是需要按确认键
find ~ -type f -name 'foo*' -exec ls -l '{}' ';' //删除搜索到的文件
```

**5、xargs**

​		 xargs 命令会执行一个有趣的函数。它从标准输入接受输入，并把**输入转换为一个特定命令的参数列表**。从而提高执行效率。

```js
//find 命令的输出被管道到 xargs 命令，反过来，xargs 会为 ls 命令构建参数列表，然后执行 ls 命令。
find ~ -type f -name 'foo\*' -print | xargs ls -l
//找出playground文件夹下所有的名称为'file-A'的文件
find playground -type f -name 'file-A'

```



### 4、归档和备份

```bash
• gzip – 压缩或者展开文件
• bzip2 – 块排序文件压缩器
归档程序：
• tar – 磁带打包工具
• zip – 打包和压缩文件
还有文件同步程序：
• rsync – 同步远端文件和目
```

**1、压缩文件**

​		压缩算法（数学技巧被用来执行压缩任务）分为两大类，**无损压缩和有损压缩**。无损压缩保留了 原始文件的所有数据。这意味着，当还原一个压缩文件的时候，还原的文件与原文件一模一样。 而另一方面，有损压缩，执行压缩操作时会删除数据，允许更大的压缩。

+ gzip。这个 gzip 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 gunzip 程序被用来把压缩文件复原为没有被压缩的版本。

  ```js
  gzip 1.txt// 压缩
  gunzip 1.txt.gz //解压，解压时不用写.gz后缀也可以
  //浏览压缩文件的内容
  gunzip -c foo.txt | less
  //浏览压缩文件的内容
  zcat foo.txt.gz | less
  ```

  gzip的选项：

  | 选项    | 说明                                                         |
  | ------- | ------------------------------------------------------------ |
  | -c      | 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。 |
  | -d      | 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定. |
  | -f      | 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选 项来指定。 |
  | -h      | 显示用法信息。也可用--help 选项来指定。                      |
  | -l      | 列出每个被压缩文件的压缩数据。也可用--list 选项。            |
  | -r      | 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursiv e 选项来指定。 |
  | -t      | 测试压缩文件的完整性。也可用--test 选项来指定。              |
  | -v      | 显示压缩过程中的信息。也可用--verbose 选项来指定。           |
  | -number | 设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之 间的整数。 数值1和9也可以各自用--fast 和--best 选项来表示。默认值是整数 6。 |

+ zip 

  ```js
  zip options zipfile file...
  zip -r playground.zip playground  //压缩文件
  unzip playground.zip	//解压
  unzip -l playground.zip playground/dir-87/file-Z  //选择性的解压文件
  ls -l /etc/ | zip ls-etc.zip - //最后面的横杠为"标准输入作为输入文件"
  ```

  

**2、归档文件**

​		归档就是收集许多文件，并把它们捆绑成一个大文件的过程。

+ tar——tape archive的简称。到扩展名为 .tar 或者 .tgz 的文件，它们各自表示“普通” 的 tar 包和被 gzip 程序压缩过的 tar包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者 两者混合体组成。**必须先指定模式，然后再指定选项。**

  ```js
  tar mode[options] pathname... //mode表示操作模式
  tar cf playground.tar playground //将playground目录创建为playground.tar包 c是模式，f是选项
  tar xf ../playground.tar   //将归档文件抽取出来
  tar xf archive.tar pathname... //通过指定路径名来抽取指定的文件
  find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'//们使用 find 命令来匹配 playground 目录中所有名为 file-A 的文件，然后使用-exec 行为，来 唤醒带有追加模式（r）的 tar 命令，把匹配的文件添加到归档文件 playground.tar 里面。
  ```

  tar有以下**操作模式**

  | 模式 | 说明                               |
  | ---- | ---------------------------------- |
  | c    | 为文件和／或目录列表创建归档文件。 |
  | x    | 抽取归档文件。                     |
  | r    | 追加具体的路径到归档文件的末尾。   |
  | t    | 列出归档文件的内容。               |
  
  ```bash
  tar xzf diction.tar.gz //抽取(-z)gzip压缩过的文件
  ```
  
  

### 5、文本处理

```js
• sort – 给文本行排序
• uniq – 报告或者省略重复行
• cut – 从每行中删除文本区域
• paste – 合并文件文本行
• join – 基于某个共享字段来联合两个文件的文本行
• comm – 逐行比较两个有序的文件
• diff – 逐行比较文件
• patch – 给原始文件打补丁
• tr – 翻译或删除字符
• sed – 用于筛选和转换文本的流编辑器
• aspell – 交互式拼写检查器
```

**1、sort**

​		sort 程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序 结果发送到标准输出。

```js
sort foo.txt// 对foo.txt的文件内容进行排序
sort file1.txt file2.txt file3.txt > final_sorted_list.txt //将文件排序并输入到另一个文件中
ls -l /usr/bin | sort -nr -k 5 | head //忽略 ls 程序能按照文件大小对输出结果进行排序
sort -t ':' -k 7 /etc/passwd | head  //按':'为分隔符，按照第7个字段进行排序
```

sort 程序有几个有趣的选项。

| 选项 | 长选项                   | 含义                                                         |
| ---- | ------------------------ | ------------------------------------------------------------ |
| -b   | --ignore-leading-bla nks | 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项 导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排 序。 |
| -f   | --ignore-case            | 让排序不区分大小写。                                         |
| -n   | --numeric-sort           | 基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而 不是字母值。 |
| -r   | --reverse                | 按相反顺序排序。结果按照降序排列，而不是升序。               |
| -k   | --key=field1[,field2]    | 对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的 讨论。 |
| -m   | --merge                  | 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排 好序的文件，而没有执行额外的排序。 |
| -o   | --output=file            | 把排好序的输出结果发送到文件，而不是标准输出。               |
| -t   | --field-separator=ch ar  | 定义域分隔字符。默认情况下，域由空格或制表符分隔。           |

**2、切片和切块**

+ **cut**

​		 cut 程序被用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。

​		cut程序主要有以下选项：

| 选项          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| -c char_list  | 从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成。 |
| -f field_list | 从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能包括一个或多个字段，或由逗号分隔开的字段区间。 |
| -d delim_char | 当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必 须由单个 tab 字符分隔开。 |
| --complement  | 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。       |

```js
//将distros.txt每行，按tab键分割，然后取分割后每行的第3个数据
cut -f 3 distros.txt  
//从第3个数据中，抽取7-10位置的字符
cut -f 3 distros.txt | cut -c 7-10 
//指定冒号做为字段分隔符。并只取前1个数据
cut -d ':' -f 1 /etc/passwd | head 
```

+ **paste**

  ​		paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。 它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准出。

  ```js
  //将distros-versions.txt文件中对应行的数据distros-dates.txt对应行的后面
  paste distros-dates.txt distros-versions.txt 
  ```

+ **join**

  ​		把来自于多个基于共享 关键域的文件的数据结合起来。

  ```js
  join distros-key-names.txt distros-key-vernums.txt 
  ```

**3、比较文本**

+ **comm**

  comm 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文把行。 

  ```js
  comm 1.txt 2.txt //比较1.txt和2.txt的差异 ，会显示三列数据，1列共有的，2列各自独有的
  comm -12 file1.txt file2.txt //只显示共有列，隐藏独有列
  ```

+ **diff**

  diff 程序被用来监测文件之间的差异。最流行的两种格式是上下文模式和统一模式。

  ```js
  //上下文模式
  diff -c file1.txt file2.txt
  //统一模式
  diff -u file1.txt file2.txt
  ```

+ **patch**

  ​		这个 patch 程序被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来 把较老的文件版本转变为较新的文件版本。

  ```js
  //创建diff文件
  diff -u 1.txt 2.txt > patch.txt
  //把旧文件修补成新文件。
  patch patch.txt
  ```

**4、运行时编辑**

+ tr

  tr 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。 换字是一种把字符从一个字母转换为另一个字母的过程。

  ```js
  //将小写转换成大写
  echo "lowercase letters" | tr a-z A-Z 
  //将小写字母转换成大写A
  echo "lowercase letters" | tr [:lower:] A 
  //删除相邻重复的字符
  echo "aaabbbccc" | tr -s ab 
  ```

+ sed 

  ​		名字 sed 是 `stream editor`（**流编辑器**）的简称。它对文本流进行编辑，要不是一系列指定的文件， 要不就是标准输入。

  ​		sed的命令开始与单个字符。替换命令由字母s来代表，后面跟着查找和替换字符串，分隔符的选择是随意的，一般用斜杆字符。

  ```bash
  echo "front" | sed "s/front/back/" //用back替换front类似于替换查找操作
  echo "front" | sed '2s/front/back/' //给命令添加地址2，对输入流的第2行进行替换操作
  ```

  地址有很多方式来表达，下面是常用的sed地址表示法：	

  | 地址        | 说明                                                         |
  | ----------- | ------------------------------------------------------------ |
  | n           | 行号，n 是一个正整数。                                       |
  | $           | 最后一行。                                                   |
  | /regexp/    | 所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界 定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定 表达式，这里 c 就是一个备用的字符。 |
  | addr1,addr2 | 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。 |
  | first~step  | 匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本 行。 |
  | addr1,+n    | 匹配地址 addr1 和随后的 n 个文本行。                         |
  | addr!       | 匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。 |

  sed的基本编辑命令如下所示：

  | 命令                  | 说明                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | =                     | 输出当前的行号。                                             |
  | a                     | **在当前行之后追加文本。**                                   |
  | d                     | 删除当前行。                                                 |
  | i                     | **在当前行之前插入文本。**                                   |
  | p                     | 打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地 址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。 |
  | q                     | 退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。 |
  | Q                     | 退出 sed，不再处理更多的文本行。                             |
  | s/regexp/replacement/ | 只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可 能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能 包含序列 \1到 \9，其是 regexp 中相对应的子表达式的内容。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。 |
  | y/set1/set2           | 执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不 同于 tr 程序，sed 要求两个字符集合具有相同的长度。 |

  ```bash
  echo "2019/12/30" | sed "s/\//-/g" //将"/"替换为"-"
  cat test.txt | sed "s/\//-/g" > replace.txt //将test.txt文件中的所有"/"都替换为"-"，并输出到replace.txt中
  ```

  使用`-f`选项，格式化文件。

  ```bash
  //使用distros.sed来格式化distros.txt中的代码
  sed -f distros.sed distros.txt 
  //替换修改foo.txt文件中的相关字符串
  sed -i 's/lazy/laxy/; s/jumped/jimped/' foo.txt
  
  ```

+ aspell

  ​		一款交互式的拼写检查器。它能够智能地检查各种类型的文本文件， 包括 HTML 文件，C/C++ 程序，电子邮件和其它种类的专业文本。

  ```js
  aspell check textfile
  ```

  注意：一旦结束aspell操作，再用aspell检查不会再有任何效果了。除非你又修改了该文件。



### 6、格式化输出

  **1、nl**

  ​		像cat一样，nl能够接受多个文件作为命令行参数，也能标准输出。 nl有一些常用的选项，相当于`cat -n`。

| 选项      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| -b style  | 把 body 按被要求方式数行，可以是以下方式：<br/>a = 数所有行<br/>t = 数非空行。这是默认设置。<br/>n = 无<br/>pregexp = 只数那些匹配了正则表达式的行 |
| -f style  | 将 footer 按被要求设置数。默认是无                           |
| -h style  | 将 header 按被要求设置数。默认是无                           |
| -i number | 将页面增加量设置为数字。默认是1。                            |
| -n format | 设置数数的格式，格式可以是：<br/>ln = 左偏，没有前导零。<br/>rn = 右偏，没有前导零。<br/>rz = 右偏，有前导零。 |
| -p        | 不要在每一个逻辑页面的开始重设页面数。                       |
| -s string | 在每一个行的末尾加字符作分割符号。默认是单个的 tab。         |
| -v number | 将每一个逻辑页面的第一行设置成数字。默认是1。                |
| -w width  | 将行数的宽度设置，默认是6。                                  |

  **2、fold**

  ​		像其他命令，fold 接受一个或多个文件及标准输入。显示文件行宽。跟`nl`的选项一样。

  ```bash
//限制行宽为12个字符，-s表示会考虑单词边界，按单词为单位。不会拆分单词。
echo "The quick brown fox jumped over the lazy dog." | fold -w 12 -s  
  ```



### 7、编译程序

**1、什么是编译？**

​		编译就是把源码（一个由程序员编写的人类可读的程序描述）翻译成计算机处理器的母语的过程。但是`shell`脚本不需要编译，它是**脚本或解释型语言**。脚本语言由一个叫做解释器的特殊程序执行。**解释型程序执行起来要比编译程序慢很多**。这是因为每次解释型程序执行时，程序中每一条源码指令都需要翻译， 而一个编译程序，一条源码指令只翻译一次，翻译后的指令会永久地记录到最终的执行文件中。**开发解释型程序 要比编译程序快速且容易。**

**2、获取源码**

```bash
ftp ftp.gnu.org 
cd gnu/diction 
get diction-1.11.tar.gz 
bye 
tar xzf dict-1.111.tar.gz
```

**2、解读源码**

**构建程序**

大多数程序通过一个简单的，两个命令的序列构建：

```bash
./configure 
make 
```

`		configure`程序是shell脚本，它的工作是为了分析程序建立环境。**`configue`是为了检查是否安装了必要的外部工具和组件。**`./`表示当前工作目录。运行会会创建一些文件如`Makefile`。

`make`程序会把`makefile`作为输入，`makefile`描述了包括最终完成的程序的各组件之间的关系和依赖性。`make` 只是构建 需要构建的部分，而不是简单地重新构建所有的内容。

**安装程序**

​		打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。

```bash
make install
```



  