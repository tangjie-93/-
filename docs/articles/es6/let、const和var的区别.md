---
title: let、const和var的区别
date: '2020-03-15'
type: 技术
tags: es6
note: let、const和var的区别
---
let用来声明变量。它的用法类似于var，但是**所声明的变量，只在let命令所在的代码块内有效**。        
**let和const有几个特点：**  
+ 不存在变量声明提升。    
+ 暂时性死区（只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。）。    
+ 不允许重复声明。不允许在相同作用域内，重复声明同一个变量。  
+ 块级作用域。
+ `let、const`声明的全局变量不会挂在顶层对象上。

**`let`跟`const`的区别**
+ `let`可以先声明稍后再赋值,而`const`在 声明之后必须马上赋值，否则会报错.
+ `const` 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。
+ `let`的常见使用场景是`声明变量`。
+ `const`的常见使用场景是`声明常量、匿名函数和箭头函数`
```js   
//块级作用域的例子
{
        let a=12;
        var b=23;
}
console.log(b);//23
console.log(a);// a is not defined
for(let i=0;i<10;i++){				
        
}
console.log(i);// is not defined
-----------------------------------------------------------------
var a = [];
for (let i = 0; i < 10; i++) {
        a[i] = function () {
        console.log(i);
        };
}
a[6](); // 6
```
&#8195;&#8195;分析：变量i是let声明的，所以i只在let声明的代码块内有效。for循环一共循环了10次，每一次都是一个独立的代码块——{}，所以每次循环中的i都是独立的，当前的i只在当前循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。     
**&#8195;&#8195;for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。**
```js       
for (let i = 0; i < 3; i++) {
        let i = 'abc';
        console.log(i);
}
// abc
// abc
// abc
```
**2.2 不存在变量声明提升**
```js      
// var 的情况
console.log(foo); // 输出undefined，变量声明提升，相当于在输出之前就var  foo；
var foo = 2;
// let 的情况
console.log(bar); // 报错ReferenceError，没有变量声明提升
let bar = 2;
```
**2.3 暂时性死区（temporal dead zone，简称 TDZ）**  
&#8195;&#8195;在区块中使用let和const命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错(声明之前都是死区)。**本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。**  

**2.4 不允许重复声明**

&#8195;&#8195;let不允许在相同作用域内，重复声明同一个变量。
```js        
function func() {
        let a = 10;
        var a = 1;
}
funb()// // 报错 Identifier 'a' has already been declared

function func() {
        let a = 10;
        let a = 1;
}
func()// 报错 Identifier 'a' has already been declared
————————————————————————————————————————————————————————
function bar(x = y, y = 2) {
        return [x, y];
}
bar(); // 报错   参数x默认值等于另一个参数y，而此时y还没有声明，属于"死区"(参数读取从左至右)。
&#8195;&#8195;不能在函数内部重新声明参数。

function funb(arg) {
        let arg;
}
func() // 报错Identifier 'arg' has already been declared     形参arg跟局部变量arg在同一个{}内，所以报错
function func(arg) {
        {
                let arg;
                console.log(arg);//undefined
        }
        console.log(arg);//34
}
func(34)
```
**2.5 块级作用域**  

优点：
>1、没有块级作用域，内层变量可能会覆盖外层变量(变量声明提升)。    
>2、用来计数的循环变量会泄露为全局变量。    

特点：
>1、允许任意嵌套。  
2、外层作用域无法读取内层作用域的变量。    
3、使得立即执行函数不再必要了。    
4、允许在块级作用域中声明函数，函数声明类似于var，函数声明会提升到所在的块级作用域的头部。

**2.6 const**  

&#8195;&#8195;const一旦声明变量，就必须立即初始化，不能留到以后赋值,且变量的值也不能改变。**本质：并不是变量的值不得改动，而是变量指向的那个内存地址所不得改动。**    
&#8195;&#8195;对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

1、变量指向的是对象时，可以改变该对象的属性。但是不可将该变量指向另一个对象。
```js 
const obj = {}
// 为 foo 添加一个属性，可以成功
obj.prop = 123;
// 将 obj 指向另一个对象，就会报错，此时已经改变了obj所指向的内存地址了
obj = {}; // TypeError: "foo" is read-only
```  
2、变量指向的是数组时，可以改变该数组中的元素及数组的属性。但是不可将该变量指向另一个数组。
```js
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错，指向了另一个数组
```     
**2.7	ES6声明变量的6种方式**

&#8195;&#8195;var、function、let、const、class、import。es5只有var和function两种。  
&#8195;&#8195;**顶层对象的差异：** 在浏览器环境指的是window对象，在 Node中 指的是global对象，在Web Worker 里面，self也指向顶层对象。   
&#8195;&#8195;ES5 之中，顶层对象的属性与全局变量是等价的。ES6中的var命令和function命令声明的全局变量，依旧是顶层对象的属性；let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
```js       
var a = 1;
window.a // 1

let b = 1;
window.b // undefined
```