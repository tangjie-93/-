---
title: 数据结构和算法基础知识总结
date: '2020-03-24'
type: 技术
tags: 算法
note: 数据结构和算法基础知识总结
---
<img src="../../images/算法脑图.jpeg">

**时间复杂度**
&#8195;&#8195;在进行算法分析时，语句总是随着执行次数 `T(n)` 是关于问题规模 `n` 的函数。进而分析 `T(n)`的数量随 `n` 的变化情况并确定 `T(n)` 的数量级。算法的时间复杂度，也就是算法的时间量度，记做 `T(n)=O(f(n))`。它表示随问题规模 `n` 的增大，算法执行时间的增长率和 `f(n)` 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 `f(n)` 是问题规模 `n` 的某个函数。
**空间复杂度**
&#8195;&#8195;通过计算算法所需的存储空间实现。`S(n)=O(f(n))`，其中 `n`为问题的规模，`f(n)`为语句关于 `n` 所占存储空间的函数。一般会在函数中以数组的形式存在。一维数组的话空间复杂度就是数组的长度 `（n）`。 二维数组的空间复杂度为 `n^2`

## 1、线性表

&#38195;&#38195;零个或多个数据元素的有限序列。

### **1、 线性表的顺序存储结构**

&#8195;&#8195;用一段地址连续的存储单元依次存储线性表的数据元素。

**优点**

+ 无需为表示表中元素之间的逻辑关系而增加额外的存储空间。
+ 可以快速的存取表中任意位置的元素。

**缺点**

+ 插入和删除需要移动大量元素。
+ 当线性表长度变化较大时难以确定存储空间的容量。
+ 造成存储空间的碎片。

### **2、线性表的链式存储结构**

&#8195;&#8195;对数据元素来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储**直接后继位置**的域称为指针域。指针域中存储额信息称为指针或链这两部分信息组成结点。多个节点链接成一个链表，称为线性表的链式存储结构。

#### 2.1、单链表
&#8195;&#8195;链表中的每个节点只包含一个指针域，称为单链表。链表中的**第一个节点的存储位置称为头指针**。在单链表的第一个结点前附设一个结点，称为**头结点**。头结点的指针域存储指向第一个结点的指针。线性链表的最后一个节点指针为**空**（通常用`NULL`表示）

**头指针**

+ 指链表中指向第一个节点的指针。
+ 头指针具有标识作用，所以常以头指针冠以链表的名字。
+ 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

**头结点**

+ 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义。
+ 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作和其他结点的操作就统一了。
+ 头结点不一定是链表必须元素。

**单链表和顺序存储结构的优缺点**

> 1、存储分配方式
+ 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。
+ 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。

>2、时间性能
+ 查找
    + 顺序存储结构 `O(1)`
    + 单链表 `O(n)`
+ 插入和删除
    + 顺序存储结构 `O(n)`
    + 单链表 `O(1)` 

>3、空间性能
+ 顺序存储结构需要预分配存储空间，空间分大了，浪费，分小了容易发生上溢。
+ 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。数据元素可以存在内存未被占用的任意位置。

#### 2.2、静态链表
&#8195;&#8195;用数组描述的链表。数组的元素由两个数据域组成，`data`和`cur`。`data`用来存放数据元素，`cur`相当于单链表中的 `next` 指针。

**优点**

+ 在插入和删除操作时，只需要移动游标，不需要移动元素，从而改进在顺序存储结构中的插入和删除操作要移动大量元素的缺点。

**缺点**

+ 没有解决连续存储分配带来的表长难以确定的问题。
+ 失去了顺序存储结构随机存取的特性。

#### 2.3、循环链表
&#8195;&#8195;将单向链表中终端结点的指针端由空指针改为指向头结点，就使单链表形成一个环，这种首位相连的单链表称为循环链表。
#### 2.4、双向链表
&#8195;&#8195;在单链表的每个节点中，再设置一个指向其前驱结点的指针。

## 2、栈和队列

### **2.1 栈**
&#8195;&#8195;栈是限定仅在表尾进行插入和删除操作的线性表。允许删除和插入的一端称为**栈顶**，另一端称为**栈底**。栈又被称为后进先出的线性表(`Last In First Out`),简称`LIFO`操作。

### **2.2 队列**
&#8195;&#8195;队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。是一种先进先出(`First In First Out`)的线性表。

## 3、树
&#8195;&#8195;结点拥有的子树称为结点的度，度为 `0` 的结点称为叶结点，度不为 `0`的称为分支节点。树的度是树内各节点的度的最大值。树中结点的最大层次称为树的深度或高度。

**3.1、二叉树**
+ 每个结点最多有两棵子树。
+ 左子树和右子树是有顺序的。
+ 即使树中某节点只有一颗子树，也要区分是左子树还是右子树。


**3.2、特殊二叉树**
+ 斜树

&#8195;&#8195;所有的结点都只有左子树的二叉树叫左斜树，所有的结点都只有右子树的二叉树叫右斜树。
+ 满二叉树

&#8195;&#8195;所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

&#8195;&#8195;**特点：1、叶子只能出现在最下一层；2、非叶子结点的度一定是2；3、在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。**

+ 完全二叉树

&#8195;&#8195;对一棵具有n个结点的二叉树按层序编号，如果编号为`i(i≤i≤n)`的结点与同样深度的满二叉树中编号为`i`的结点在二叉树中位置完全相同。判断是否是完全二叉树的最简单方法就是按满二叉树的结构给结点编号，看是否连续，连续则是完全二叉树，否则不是。

&#8195;&#8195;**特点： 1、叶子结点只能出现在最下两层；2、最下层的叶子一定集中在左部连续位置；3、如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。4、同样结点的二叉树，完全二叉树的深度最小。5、给定的某个节点下标`i`,可以很容易的计算出此结点的父结点和孩子结点的下标。**
```js
Parent(i)=Math.floor(i/2);//父结点的下标
Left(i)=2i;//左子结点的下标
Right(i)=2i+1;//右子结点的下标
```

**3.3、二叉树的性质**
+ 在二叉树的第i层上至多有`2^i-1`个结点。
+ 深度为k的二叉树至多有 `2^k-1` 个结点（`k≥1`）。
+ 对任何一棵二叉树，如果其终端节点树为 `n0`,度为2的结点数为 `n2`，则 `n0=n2+1`。
```js
//数的结点总数 n0为终端节点个数，n1位度为1的结点个数，n2位度为2额结点个数，
n=n0+n1+n2
n-1=n1+2n2
n0=n2+1
```
+ 具有n个结点的完全二叉树的深度为`|log2n|+1`。
+ 如果对一棵有n个结点的完全二叉树的结点按层序编号对任一节点i有：
    + 如果`i=1`，则结点是二叉树的根，无双亲；如果`i>1`,则其双亲是节点`|i/2|`。  
    + 如果 `2i>n` ,则结点 i 无左孩子（结点i是叶子结点）；否则其左孩子是叶子结点。
    + 如果 `2i+1>n`,则结点i无右孩子；否则其右孩子是结点 `2i+1`。

**3.5、遍历二叉树**

<img src="../../images/二叉树遍历.jpg" height="300px" >

> 1、前序遍历

&#8195;&#8195;先访问根节点，然后前序遍历左子树，再前序遍历右子树。简称为**根左右**。 遍历顺序为`ABDGHCEIF`。


> 2、中序遍历

&#8195;&#8195;中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。简称**左内右**。遍历顺序为`GDHBAEICF`

> 3、后序遍历

&#8195;&#8195;从左到右先叶子后节点的方式遍历访问左右子树，**最后是根节点**。简称**左右内**。遍历顺序为`GHDBIEFCA`

> 4、层序遍历
&#8195;&#8195;从树的第一层，从根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。遍历顺序为`ABCDEFGHI`。

**3.6 树、森林、和二叉树的转换**

> 1、树转换为二叉树
+ 加线。在**所有兄弟结点之间加一条连线**。
+ 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
+ 层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。

> 2、森林转换为二叉树

&#8195;&#8195;森林是由若干棵树组成。
+ 把每个树转换为二叉树。
+ 第一棵树不动，从第二棵树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。当所有的二叉树连接起来后就得到了由森林转换而来的二叉树。

> 3、二叉树转换为树
+ 加线。若某节点的左孩子结点存在，**则将这个孩子的右孩子结点、右孩子的右孩子结点，反正就是左孩子的n个右孩子都作为此结点的孩子。。将该结点与这些右孩子用线连接起来。**
+ 去线。删除原二叉树中所有结点与其右孩子结点的连线。
+ 层次调整。
> 4、二叉树转换为森林
+ 从根节点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除。。。，直到所有右孩子都删除为止，得到分离的二叉树。
+ 再将每棵分离后的二叉树转换为树即可。

**3.7、赫夫曼树及其应用**

&#8195;&#8195;从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作**路径长度**。**树的路径长度**就是从根结点到每一结点的路径长度总和。树的带权路径长度为树中所有子结点的带权路径长度之和。**带权路径长度WPL最小的二叉树称作赫夫曼树。**

规定赫夫曼树的左分支代表`0`，右分支代表`1`，则从根结点到叶子结点所经过的路径分支组成的`0`和`1`的序列便为该结点对应字符的编码，这就是**赫夫曼编码**。

