---
title: 数据结构之字符串总结
date: '2020-12-23'
type: 技术
tags: 算法
note: 该文章主要用来总结一下字符串匹配算法
---
&#8195;&#8195;字符串匹配算法比较多，这里主要总结6种常见的字符串匹配算法。`BF`算法、`RK`算法以及`BM`算法和`KMP`算法，这4种是单模式串匹配算法；以及`Trie`树和`AC`自动机这两种多模式匹配算法。
## 1、单模式匹配算法

### 1、BF算法
&#8195;&#8195;`BF` 算法是 `Brute Force` 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。假如字符串 `A`是主串，长度是`n`,字符串`B`是模式串，长度是`m`,因为我们在主串中查找模式串，所以`n>m`。 用一句话概括就是：**我们在主串中，检查起始位置分别是 `0、1、2…n-m` 且长度为 `m` 的 `n-m+1` 个子串，看有没有跟模式串匹配的。** `BF` 算法的**时间复杂度很高，是 `O(n*m)`**（遍历`n-m+1`次，每次都需要比较每个字符，字符长度为`m`）。

### 2、RK算法——借助哈希算法实现高效字符串匹配。

&#8195;&#8195;`RK` 算法的全称叫 `Rabin-Karp` 算法。
&#8195;&#8195;`RK` 算法的思路是这样的：我们通过哈希算法对主串中的 `n-m+1` 个子串分别**求哈希值**，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。
&#8195;&#8195;整个`RK`算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值的比较。通过扫描一遍主串就可以计算出所有子串的哈希值，这部分的时间复杂度是`O(n)`。模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 `O(1)`，总共需要比较 `n-m+1` 个子串的哈希值，所以，这部分的时间复杂度也是 `O(n)`。所以，`RK` 算法整体的**时间复杂度就是 `O(n)`**。
&#8195;&#8195;可以利用二十六进制来计算字符串的哈希值。把`a-z`这26个字符映射到`0-25`这26个数字。
```js
"cba"="c"*26^2+"b"*26+"a"*1；=2*26^2+26+1=1353；
```
&#8195;&#8195;当一个子串的哈希值跟模式串相等的时候，比较一下子串和模式串本身就可以了。
&#8195;&#8195;`RK` 算法是借助哈希算法对 `BF` 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 `O(n)`。

### 3、BM算法——实现文本编辑器中的查找功能

&#8195;&#8195;`BM（Boyer-Moore）`算法是一种非常高效的字符串匹配算法，根据实验统计，它的性能是著名的`KMP`算法的3到4倍。
&#8195;&#8195;`BM（Boyer-Moore）`算法的核心思想。就是在模式串和主串不匹配的时候，能够跳过一些肯定不会匹配的情况时，将模式串往后多滑动几位。
#### 1、BM算法原理分析
&#8195;&#8195;`BM` 算法包含两部分，分别是坏字符规则 `(bad character rule)` 和好后缀规则  `(good suffix shift)`。
##### 1、坏字符规则
&#8195;&#8195;我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）。
<img src="../../images/bad-charactor-rule.jpg" alt="暂无图片" />

&#8195;&#8195;当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 `si`。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 `xi`。如果不存在，我们把 `xi` 记作 `-1`。那模式串往后移动的位数就等于 `si-xi`。（注意，我这里说的下标，都是字符在模式串的下标）。
<img src="../../images/bad-charactor-rule2.jpg"  alt="暂无图片"/>

&#8195;&#8195;如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。

&#8195;&#8195;利用坏字符规则，`BM` 算法在最好情况下的时间复杂度非常低，是 `O(n/m)`。比如，主串是 `aaabaaabaaabaaab`，模式串是 `aaaa`。每次比对，模式串都可以直接后移四位。

&#8195;&#8195;单纯使用坏字符规则还是不够的。因为根据 `si-xi` 计算出来的移动位数，有可能是负数，比如主串是 `aaaaaaaaaaaaaaaa`，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。`si=0,xi=1`,向后滑动一位，所以`BM`算法还需要用到`好后缀规则`。

##### 2、好字符规则

<img src="../../images/good-suffix.jpg" alt="好后缀规则" />

&#8195;&#8195;**我们把已经匹配的 `bc` 叫作好后缀，记作 `{u}`。我们拿它在模式串中查找，如果找到了另一个跟 `{u}` 相匹配的子串 `{u*}`，那我们就将模式串滑动到子串 `{u*}`与主串中 `{u}`对齐的位置。**
<img src="../../images/good-suffix2.jpg" alt="暂无图片" />

&#8195;&#8195;如果在模式串中找不到另一个等于 `{u}` 的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中 `{u}` 的情况。

<img src="../../images/good-suffix3.jpg" alt="暂无图片" />

&#8195;&#8195;当模式串滑动到前缀与主串中 `{u}` 的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。
<img src="../../images/good-suffix4.jpg" alt="暂无图片" />

&#8195;&#8195;字符串 `s` 的**后缀子串**，就是最后一个字符跟 `s` 对齐的子串，比如 `abc` 的后缀子串就包括 `c, bc`。所谓**前缀子串**，就是起始字符跟 `s` 对齐的子串，比如 `abc` 的前缀子串有 `a，ab`。我们**从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。**

<img src="../../images/good-suffix5.jpg" alt="暂无图片" />

&#8195;&#8195;当模式串和主串中的某个字符不匹配的时候，**如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数?** 我们可以分别计算好后缀和坏字符往后滑动的位数，然后**取两个数中最大的**，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。

##### 3、BM算法代码实现
&#8195;&#8195;可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。
```js
/**
 * 
 * @param {String} b 模式串
 * @param {Number} m 模式串的长度
 * @return {*} bc 散列表
 */
function generateBC(b,m,bc){
  const bc=new Array(m).fill(-1);
  for(let i=0;i<m;i++){
    const ascii=b[i].charCodeAt();
    bc[ascii]=i;
  }
  return bc;
}
/**
 * 坏字符规则的框架代码
 * @param {String} a  主串
 * @param {Number} n  主串的长度
 * @param {String} b  模式串
 * @param {Number} m  模式串的长度
 */
function bm(a,n,b,m){
  const bc=new Array(256);
  generateBC(b,m,bc);//构建换字符哈希表
  let i=0;//i表示住串与模式串对齐的第一个字符
  while(i<=n-m){
    let j;
    for(j=m-1;j>=0;j--){ //模式串从后往前匹配
      if(a[i+j]!==b[j]) break;
    }
    if(j<0) return i;//匹配成功，返回主串和模式串第一个匹配的位置
    //等同于将模式串往后滑动j-bc[a[i+j]]位  
    //bc[a[i+j].charCodeAt()]表示坏字符在模式串中的索引
    i=i+(j-bc[a[i+j].charCodeAt()]);

  }
  return -1
}
```
**suffix数组：** `suffix` 数组的下标 `k`，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀 `{u}` 相匹配的子串 `{u*}` 的起始下标值。
**prefix数组：** 用于记录模式串的后缀子串是否能匹配模式串的前缀子串。
**如何来填充这两个数组的值？**
<img src="../../images/suffix-prefix.jpg" alt="暂无图片 />

分析：**后缀子串**在整个模式串中的索引是 `suffix[i]=s.slice(0,-1).indexof(后缀子串)`的值；`prefix[i]表示suffix[i]在前缀子串中的索引值是否等于0`。 `cabcab`的前缀子串有`a,ca,cab,cabc,cabca`
```js
//用于计算好好后缀规则
function generateGS(b,m){
 const suffix=new Array(m).fill(-1);
 const prefix=new Array(m).fill(false);
 for(let i=0;i<m-1;i++){
   let j=i,k=0;//k表示公共后缀子串长度
   while(j>=0&&b[j]==b[m-i-k]){
    --j;
    ++k;
    suffix[k]=j+1;//j+1表示公共后缀子串在b[0,i]中的起始下标
   }
   if(j===-1)  prefix[k]=true;//表示公共后缀子串也是模式串的前缀子串
 }
}
```
**BM**算法的完整版代码实现如下所示：
```js
function bm(a,b){
  const n=a.length,m=b.length;
  const bc=generateBC(b,m);
  const suffix=new Array(m).fill(-1);
  const prefix=new Array(m).fill(false);
  generateGS(b,m,suffix,prefix);
  let i=0;//j表示主串跟模式串匹配的第一个字符
  while(i<=n<m){
    let j;
    for(j=m-1;j>=0;j--){//模式串从后往前匹配
      if(a[i+j]!==b[j]) break;//坏字符对应模式中的下标是将j
    }
    if(j<0) return i;//匹配成功，返回主串跟模式串第一个匹配的字符的位置
    let x=j-bc[a[i+j].charCodeAt()];//表示移动的位数
    let y=0;
    if(j<m-1){
      y=moveByGS(j,m,suffix,prefix);
    }
    i=i+Math.max(x,y);//表示移动的位数
  }
  return -1
}
//bc表示字符的编码值在模式串中的索引
function generateBC(b,m){
  const bc=new Array(m).fill(-1);
  for(let i=0;i<m;i++){
    const ascii=b[i].charCodeAt();
    bc[ascii]=i;
  }
  return bc;
}
//判断后缀子串跟前缀子串是否有相等的情况
function generateGS(b,m,suffix,prefix){
  for(let i=0;i<m-1;i++){
    let j=i,k=0;//k表示公共后缀子串长度
    while(j>=0&&b[j]==b[m-i-k]){
     --j;
     ++k;
     suffix[k]=j+1;//j+1表示公共后缀子串在b[0,i]中的起始下标
    }
    if(j===-1)  prefix[k]=true;//表示公共后缀子串也是模式串的前缀子串
  }
 }
 //在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？
 function moveByGS(j,m,suffix,prefix){
  //j表示坏字符对应的模式串中的字符下标
  //j+1表示好后缀开始的位置
  let k=m-(1+j);//好后缀长度
  //1、表示好后缀跟前缀子串有相等的情况
  if(suffix[k]!==-1) return j-suffix[k]+1;//表示移动的位数
  //j是坏字符，j+1是好后缀开始字符，好后缀的子后缀是不包括第一位的，所以从j+2开始
  //2、遍历好后缀的后缀子串
  for(let r=j+2;r<=m-1;r++){
    if(prefix[m-r]){
      return r;
    }
  }
  // 前面两条规则都没有找到可以匹配好后缀及其后缀子串的子串，则将整个模式串后移m位
  return m;
 }
```

**总结：** `BM` 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。`BM` 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 `BM` 算法。

## 2、多模式匹配算法
