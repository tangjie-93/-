---
title: 算法基本思想之贪心算法
date: '2020-04-15'
type: 技术
tags: 算法
note: 算法基本思想之贪心算法
---
## 贪心算法
&#8195;&#8195;又称贪婪算法，贪心算法是一种寻找**最优解**为手段从而达成整体解决方案的算法。在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的**局部最优解**。选择的贪心策略必须具备**无后效性**，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
****
**基本要素**
+ 贪心选择：贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。贪心选择是采用**从顶向下、以迭代**的方法做出相继选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题。然后，用**数学归纳法**证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。
+ 最优子结构：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。

**基本思路**
+ 建立数学模型来描述问题
+ 把求解的问题分成若干个子问题
+ 对每一子问题求解，得到问题的局部最优解
+ 把子问题的局部最优解合成原来问题的一个解


**动态规划和贪心算法的区别**
+ 贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是；
+ 贪心算法对每个子问题的解决方案都做出选择，不能回退；
+ 动态规划则会根据以前的选择结果对当前进行选择，有回退功能；
+ 动态规划主要运用于二维或三维问题，而贪心一般是一维问题。
#### 题目1 找零问题 
> 你从商店购买了一些商品，找零 63 美分，店员要怎样给你这些零钱才能得到最少的硬币？
```js
function makeChange (origAmt, coins = {}) {
    if (origAmt % 25 < origAmt) {
        coins[25] = parseInt(origAmt / 25);
        origAmt = origAmt % 25;
    }
    if (origAmt % 10 < origAmt) {
        coins[10] = parseInt(origAmt / 10);
        origAmt = origAmt % 10;
    }
    if (origAmt % 5 < origAmt) {
        coins[5] = parseInt(origAmt / 5);
        origAmt = origAmt % 5;
    }
    coins[1] = parseInt(origAmt / 1);
    const count = Object.values(coins).reduce((cur, next) => {
        return cur + next
    })
    return count
}
var origAmt = 63;
makeChange(origAmt);
```

#### 题目2 背包问题
```js
物品 A B C D 
价格 50 220 60 60 
尺寸 5 20 10 12 
比率 10 11 6 5
```
**思路**
+ 背包的容量是 `W`,物品的价格是 `v`, 重量是 `w`。
+ 根据 `v/w` 的比率对物品排序。
+ 按比率的降序方式来考虑物品。
+ 尽可能多的放入每个物品。

```js
function greedy (values, weights, capacity) {
    var returnValue = 0
    var remainCapacity = capacity
    var sortArray = []
    //1、计算每个物品的单位重量的价值
    values.map((value, index) => {
        sortArray.push({
            'value': value,
            'weight': weights[index],
            'ratio': value / weights[index]
        })
    })
    //2、按单位价值降序排序
    sortArray.sort(function (a, b) {
        return b.ratio - a.ratio
    })
    let obj, num;
    //3、根据背包当前所剩容量选取物品
    while (remainCapacity && (obj = sortArray.shift())) {
        num = parseInt(remainCapacity / obj.weight)
        remainCapacity -= num * obj.weight
        //4、如果背包的容量大于当前物品的重量，那么就将当前物品装进去，否则循环结束
        returnValue += num * obj.value
    }
    return returnValue
}
var items = ['A', 'B', 'C', 'D']
var values = [50, 220, 60, 60]
var weights = [5, 20, 10, 12]
var capacity = 32 //背包容积
greedy(values, weights, capacity) // 320
```
#### 题目3、活动安排问题
>设有n个活动的集合 `E={1,2,…,n}`，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间 `fi`,且 `si <fi` 。要求设计程序，使得安排的活动最多。

**问题分析：**

&#8195;&#8195;设有 `n` 个活动的集合`｛0，1，2，…，n-1｝`，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间 `starti` 和一个结束时间 `endi` ，且 `starti<endi`。如选择了活动`i`，则它在半开时间区间 `[starti,endi）` 内占用资源。若区间 `[starti,endi)` 与区间 `[startj,endj)` 不相交，称活动i与活动j是相容的。

```js
function getMaxActivitis(start,end,n){
    //将开始时间和结束时间构造成一个对象
    let obj={}
    for(let i=0;i<n;i++){
        obj[i]={start:start[i],end:end[i]}
    }
    //按结束时间升序排列
    const  keysArr=Object.keys(obj).sort((a,b)=>{
        return obj[a].end-obj[b].end;
    })
    //用于存放合适时间的活动
    const arr=[]
    //用于记录合适时间的索引
    let index=0;
    arr.push([obj[keysArr[0]].start,obj[keysArr[0]].end])
    for(let i=1;i<keysArr.length;i++){
        if(obj[index].end<=obj[i].start){
            index=i;
            arr.push([obj[i].start,obj[i].end])
        }
        continue
    }
    return arr.length;
}
const start = [0,1,3,0,5,3,5,6,8,8,2,12];
const end=[0,4,5,6,7,8,9,10,11,12,13,14]
getMaxActivitis(start,end,start.length)
```
**参考资料**

[1、贪心算法总结](https://juejin.im/entry/59a7e4b3518825243507b492)